pipeline {
    agent any
    parameters {
        booleanParam(name: 'RUN_DOCKER_MVC', defaultValue: false, description: 'Run Docker MVC Pipeline')
        booleanParam(name: 'RUN_DOCKER_DB', defaultValue: false, description: 'Run Docker DB Pipeline')
    }
    environment {
        AWS_ACCESS_KEY_ID = credentials("AWS_ACCESS_KEY_ID")
        AWS_SECRET_ACCESS_KEY = credentials("AWS_SECRET_ACCESS_KEY")
        AWS_KEY_PAIR = credentials("AWS_PEM_ID")
        AWS_REGION = "eu-west-2"
        dockerHome = tool "myDocker"
		nodeHome = tool "myNodeJS"
        // groovyHome = tool "groovy"
		PATH = "$dockerHome/bin:$nodeHome/bin:$PATH"
    }
    stages {
        stage("Checkout") {
            steps {
                sh "pwd"
                sh """
                    pwd
                    ls
                    cd ../
                    pwd
                    ls
                    ls -a
                """
                echo "looking in blog_db"
                sh """
                    ls
                    cd blog_db
                    ls
                """
                echo "AWS_SECRET_ACCESS_KEY is set"
                sh "echo AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY"
                echo "AWS_ACCESS_KEY_ID"
                sh "echo AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID"
                echo "Docker Home"
                sh "docker --version"
                echo "We have node"
                sh "node --version"
                echo "We have npm"
                sh "npm --version"
                echo "checking if terraform version is working"
                sh "terraform --version"
                echo "Will kuberenetes WORK!?"
                sh "kubectl version --client"
                echo "AWS in our system?"
                sh "aws --version"
                echo "Azure found?!"
                sh "az --version"
                echo "GCP found"
                sh "gcloud --version"
                echo "ansible found"
                sh "ansible --version"
                echo "Path: $Path"
				echo "Build Number: $env.BUILD_NUMBER"
				echo "Build ID: $env.BUILD_ID"
				echo "Build URL: $env.BUILD_URL"
				echo "Build Tag: $env.BUILD_TAG"
				echo "Job Name: $env.JOB_NAME"
                echo "FINSIHED THESE STEPS"
            }
            post {
				always {
					echo "I run at the end of the build stage"
				}
			}
        }
        stage("Docker DB Pipeline") {
            when {
                expression { return params.RUN_DOCKER_DB }
            }
            steps {
                script {
                    echo "Looking if DB pipeline is there"
                    sh """
                        pwd
                        ls
                        cd blog_db
                        ls
                    """
                    dir("blog_db") {
                        script {
                            load "Jenkinsfile-Blog-DB"
                        }
                    }
                }
            }
        }

        stage("Docker MVC Pipeline") {
            when {
                expression { return params.RUN_DOCKER_MVC }
                // expression { return params.PIPELINES_TO_RUN.contains("Docker_MVC") }
            }
            steps {
                script {
                    echo "Looking if MVC pipeline is there"
                    sh """
                        pwd
                        ls
                        cd blog_mvc
                        ls
                    """
                    dir("blog_mvc") {
                        script {
                            load "Jenkinsfile-Blog-MVC"
                        }
                    }
                }
            }
        }
        stage("Terraform Init") {
            steps {
                sh "pwd"
                sh """
                pwd
                cd ~/
                pwd
                ls -a
                """
                dir("terraform") {
                    sh "pwd"
                    sh "terraform init"
                }
            }
        }
        stage("Terraform Validate") {
            steps {
                dir("terraform") {
                    sh "terraform validate"
                }
            }
        }
        stage("Terraform Plan") {
            steps {
                echo "Looking if plan wille execute"
                dir("terraform") {
                    withCredentials([file(credentialsId: 'AWS_PEM_ID', variable: "AWS_KEY_PAIR_FILE")]) {
                        sh '''
                            # Ensure the private key file is available
                            ls -l $AWS_KEY_PAIR_FILE

                            # Run terraform plan with the private key
                            terraform plan -var="aws_key_pair=${AWS_KEY_PAIR_FILE}"
                        '''
                    }
                }
            }
        }
        stage("Terraform Apply") {
            steps {
                echo "About to see if apply works"
                dir("terraform") {
                    withCredentials([file(credentialsId: "AWS_PEM_ID", variable: "AWS_KEY_PAIR_FILE")]) {
                        sh '''
                            # Ensure the private key file is available
                            ls -l $AWS_KEY_PAIR_FILE

                            # Run terraform plan with the private key
                            terraform apply -var="aws_key_pair=${AWS_KEY_PAIR_FILE}" -auto-approve
                        '''
                    }
                }
            }
        }
    }
    post {
		always {
			echo "I always run"
            echo "Final Cleanups"
            dir("blog_mvc") {
                sh "rm -rf node_modules"
                sh "ls > ls.txt"
                sh "cat ls.txt"

                script {
                    def testTxtExists = sh(script: "grep 'test.txt' ls.txt", returnStatus: true) == 0
                    if (testTxtExists) {
                        sh "cat test.txt"
                        sh "rm test.txt"
                    }


                    def coverageFileExist = sh(script: "grep 'coverage.txt' ls.txt", returnStatus: true) == 0
                    if (coverageFileExist) {
                        sh "cat coverage.txt"
                        sh "rm coverage.txt"
                    }

                    def coverageExist = sh(script: "grep 'coverage' ls.txt", returnStatus: true) == 0
                    if (coverageExist) {
                        sh "rm -rf coverage"
                    }
                }
                sh "ls"
                sh "rm ls.txt"
                sh "ls"
            }
		}
		success {
			echo "I run when successful"
		}
		failure {
            script {
                withCredentials([usernamePassword(credentialsId: "e47030c6-b9aa-4279-8df1-5ebe235f9865", usernameVariable: "EMAIL_USER", passwordVariable: "EMAIL_PASS")]) {
                    emailext (
                        to: "havendepot@gmail.com,${EMAIL_USER}",
                        // cc: "${EMAIL_USER}", // should work might need to update emailext
                        // bcc: "${EMAIL_USER}", // should work might need to update emailext
                        subject: "Jenkins Pipeline Failed: ${env.JOB_NAME} ${env.BUILD_NUMBER}",
                        body: "The Jenkins pipeline has failed. Please check the build logs for details: ${env.BUILD_URL}",
                        from: "Jenkins Pipeline <${EMAIL_USER}>",
                        mimeType: "text/plain"
                    )
                }
            }
            echo "I run when failed"
		}
	}
}


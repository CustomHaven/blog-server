pipeline {
    agent any
    environment {
        dockerHome = tool "myDocker"
		nodeHome = tool "myNodeJS"
		PATH = "$dockerHome/bin:$nodeHome/bin:$PATH"
    }
    stages {
        stage("Checkout") {
            steps {
                echo "Docker Home"
                sh "docker --version"
                echo "We have node"
                sh "node --version"
                echo "We have npm"
                sh "npm --version"
                echo "Path: $Path"
				echo "Build Number: $env.BUILD_NUMBER"
				echo "Build ID: $env.BUILD_ID"
				echo "Build URL: $env.BUILD_URL"
				echo "Build Tag: $env.BUILD_TAG"
				echo "Job Name: $env.JOB_NAME"
                echo "FINSIHED THESE STEPS"
            }
            post {
				always {
					echo "I run at the end of the build stage"
				}
			}
        }
        stage("Build App") {
            steps {
                dir("blog_mvc") {
                    sh "npm install"
                }
            }
        }
        stage("Test App") {
            steps {
                dir("blog_mvc") {
                    sh "ls"
                    echo "Checking NPM version"
                    sh "npm --version"
                    echo "starting the testing"
                    sh "npm run pipeline-test"
                    sh "ls"
                    sh "cat test.txt"
                    sh "ls"
                    // Not needed but we keep it incase
                    // Because Jenkins will judge the entire pipeline if the test is Failure
                    script {
                        def testResult = sh(script: "grep 'FAIL' test.txt", returnStatus: true)
                        if (testResult == 0) {
                            error("Tests failed! Marking the pipeline as failed.")
                        }
                    }
                }
            }
        }
        stage("App Test Coverage") {
            steps {
                dir("blog_mvc") {
                    sh "ls"
                    sh "npm --version"
                    echo "Starting Coverage Test Result"
                    
                    // Run Jest with coverage and save output to coverage.txt
                    sh "npm run pipeline-coverage"
                    echo "check if coverage is added"
                    sh "ls"
                    script {
                        // Extract the functions coverage percentage from coverage.txt
                        def funcsCoveragePercentage = sh(
                            script: """
                                grep 'All files' coverage.txt | awk -F '|' '{print \$5}' | tr -d '%'
                            """,
                            returnStdout: true
                        ).trim()
                        
                        // Check if the coverage percentage was extracted correctly
                        if (funcsCoveragePercentage == "") {
                            error("Failed to extract functions coverage percentage from coverage.txt")
                        }
                        
                        echo "Total Functions Coverage Percentage: ${funcsCoveragePercentage}%"

                        sh "ls"
                        
                        // Convert to a number and check if it's below 60
                        def coverageValue = funcsCoveragePercentage.toFloat()
                        if (coverageValue < 30) { // change to 60% when I build more tests
                            error("Functions coverage is below 60%. Failing the pipeline.")
                        } else {
                            echo "Functions coverage is sufficient. Proceeding with the pipeline."
                        }
                    }
                }
            }
        }
        stage("Build Docker Image") {
            steps {
                withCredentials([file(credentialsId: "e6cf7ce9-1111-4113-9f25-f5a662674353", variable: "ENV_FILE")]) {
                    echo "Current directory before moving into blog_mvc"
                    sh "pwd"

                    dir("blog_mvc") {
                        echo "Current directory inside blog_mvc"
                        sh "pwd"
                        sh "ls"
                        sh "rm coverage.txt"
                        sh "rm -rf coverage"
                        sh "ls"

                        script {
                            sh """
                            set -a
                            . \$ENV_FILE
                            set +a

                            # Print the environment variables to verify
                            echo "PORT=\$PORT"
                            echo "NODE_ENV=\$NODE_ENV"
                            echo "DB_USER=\$DB_USER"
                            echo "DB_HOST=\$DB_HOST"
                            echo "DB_NAME=\$DB_NAME"
                            echo "DB_PASSWORD=\$DB_PASSWORD"
                            echo "DB_PORT=\$DB_PORT"
                            echo "JWT_SECRET=\$JWT_SECRET"

                            # Build Docker image with environment variables
                            docker build \
                                --build-arg PORT=\$PORT \
                                --build-arg NODE_ENV=\$NODE_ENV \
                                --build-arg DB_USER=\$DB_USER \
                                --build-arg DB_HOST=\$DB_HOST \
                                --build-arg DB_NAME=\$DB_NAME \
                                --build-arg DB_PASSWORD=\$DB_PASSWORD \
                                --build-arg DB_PORT=\$DB_PORT \
                                --build-arg JWT_SECRET=\$JWT_SECRET \
                                -t customhaven/blog_mvc:${env.BUILD_TAG} .
                            """
                            dockerImage = docker.image("customhaven/blog_mvc:${env.BUILD_TAG}")
                        }
                    }
                }
            }
        }
        stage("Push Docker Image") {
			steps {
				script {
					docker.withRegistry("", "dockerhub") {
						dockerImage.push()
						dockerImage.push("${env.BUILD_TAG}")
					}
				}
			}
		}
    }
    post {
		always {
			echo "I always run"
		}
		success {
            dir("blog_mvc") {
                sh "ls"
                sh "cat test.txt"
                sh "rm test.txt"
                sh "rm -rf node_modules"
                sh "rm coverage.txt"
                sh "rm -rf coverage"
                sh "ls"
            }
			echo "I run when successful"
		}
		failure {
            dir("blog_mvc") {
                sh "rm -rf node_modules"
                sh "ls > ls.txt"
                sh "cat ls.txt"

                script {
                    // Check if `test.txt` is listed in `ls.txt`
                    def testTxtExists = sh(script: "grep 'test.txt' ls.txt", returnStatus: true) == 0
                    if (testTxtExists) {
                        // Run this script if `test.txt` is found in `ls.txt`
                        sh "cat test.txt"
                        sh "rm test.txt"
                    }

                    // Check if `coverage.txt` or `coverage` is listed in `ls.txt`
                    def coverageFilesExist = sh(script: "grep -E 'coverage.txt|coverage' ls.txt", returnStatus: true) == 0
                    if (coverageFilesExist) {
                        // Run these commands if `coverage.txt` or `coverage` is found in `ls.txt`
                        sh "rm coverage.txt"
                        sh "rm -rf coverage"
                    }
                }
                sh "ls"
                sh "rm ls.txt"
                sh "ls"
            }
			echo "I run when failed"
		}
	}
}
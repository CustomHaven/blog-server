pipeline {
    agent any
    environment {
        AWS_ACCESS_KEY_ID = credentials("AWS_Credentials")
        AWS_SECRET_ACCESS_KEY = credentials("AWS_Credentials")
        AWS_KEY_PAIR = credentials("AWS_PEM_ID")
        dockerHome = tool "myDocker"
		nodeHome = tool "myNodeJS"
		PATH = "$dockerHome/bin:$nodeHome/bin:$PATH"
    }
    stages {
        stage("Checkout") {
            steps {
                echo "AWS_SECRET_ACCESS_KEY is set"
                sh "echo AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY"
                echo "AWS_ACCESS_KEY_ID"
                sh "echo AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID"
                echo "Docker Home"
                sh "docker --version"
                echo "We have node"
                sh "node --version"
                echo "We have npm"
                sh "npm --version"
                echo "checking if terraform version is working"
                sh "terraform --version"
                echo "Will kuberenetes WORK!?"
                sh "kubectl version --client"
                echo "AWS in our system?"
                sh "aws --version"
                echo "Azure found?!"
                sh "az --version"
                echo "GCP found"
                sh "gcloud --version"
                echo "ansible found"
                sh "ansible --version"
                echo "Path: $Path"
				echo "Build Number: $env.BUILD_NUMBER"
				echo "Build ID: $env.BUILD_ID"
				echo "Build URL: $env.BUILD_URL"
				echo "Build Tag: $env.BUILD_TAG"
				echo "Job Name: $env.JOB_NAME"
                echo "FINSIHED THESE STEPS"
            }
            post {
				always {
					echo "I run at the end of the build stage"
				}
			}
        }
        stage("Check credentials") {
            script {
                // Use withCredentials to inject credentials into environment variables
                withCredentials([awsCredentials(credentialsId: "AWS_Credentials", accessKeyVariable: "AWS_ACCESS_KEY_ID", secretKeyVariable: "AWS_SECRET_ACCESS_KEY")]) {

                    // Log the presence of AWS_ACCESS_KEY_ID but avoid showing its value
                    echo "AWS_ACCESS_KEY_ID is set"

                    // Print non-sensitive information
                    sh """
                        echo "$AWS_ACCESS_KEY_ID is present"
                        echo "$AWS_SECRET_ACCESS_KEY is not printed for security reasons."
                    """

                    // Avoid printing the actual value of AWS_SECRET_ACCESS_KEY
                    echo "Checking AWS_SECRET_ACCESS_KEY presence"
                    sh """
                        echo "$AWS_SECRET_ACCESS_KEY is not printed for security reasons."
                    """
                }
            }
        }
        stage("Build App") {
            steps {
                dir("blog_mvc") {
                    sh "npm install"
                }
            }
        }
        stage("Test App") {
            steps {
                dir("blog_mvc") {
                    sh "ls"
                    echo "Checking NPM version"
                    sh "npm --version"
                    echo "starting the testing"
                    sh "npm run pipeline-test"
                    sh "ls"
                    sh "cat test.txt"
                    sh "ls"
                    // Not needed but we keep it incase
                    // Because Jenkins will judge the entire pipeline if the test is Failure
                    script {
                        def testResult = sh(script: "grep 'FAIL' test.txt", returnStatus: true)
                        if (testResult == 0) {
                            error("Tests failed! Marking the pipeline as failed.")
                        }
                    }
                }
            }
        }
        stage("App Test Coverage") {
            steps {
                dir("blog_mvc") {
                    sh "ls"
                    sh "npm --version"
                    echo "Starting Coverage Test Result"
                    
                    // Run Jest with coverage and save output to coverage.txt
                    sh "npm run pipeline-coverage"
                    echo "check if coverage is added"
                    sh "ls"
                    script {
                        // Extract the functions coverage percentage from coverage.txt
                        def funcsCoveragePercentage = sh(
                            script: """
                                grep 'All files' coverage.txt | awk -F '|' '{print \$5}' | tr -d '%'
                            """,
                            returnStdout: true
                        ).trim()
                        
                        // Check if the coverage percentage was extracted correctly
                        if (funcsCoveragePercentage == "") {
                            error("Failed to extract functions coverage percentage from coverage.txt")
                        }
                        
                        echo "Total Functions Coverage Percentage: ${funcsCoveragePercentage}%"

                        sh "ls"
                        
                        // Convert to a number and check if it's below 60
                        def coverageValue = funcsCoveragePercentage.toFloat()
                        if (coverageValue < 30) { // change to 60% when I build more tests
                            error("Functions coverage is below 60%. Failing the pipeline.")
                        } else {
                            echo "Functions coverage is sufficient. Proceeding with the pipeline."
                        }
                    }
                }
            }
        }
        stage("Build Docker DB Image") {
            steps {
                withCredentials([file(credentialsId: "blog_db_env", variable: "ENV_FILE_DB")]) {
                    dir("blog_db") {
                        script {
                                sh """
                                set -a
                                . \$ENV_FILE_DB
                                set +a

                                # Build Docker image with environment variables
                                docker build \
                                    --build-arg POSTGRES_DB=\$POSTGRES_DB \
                                    --build-arg POSTGRES_PASSWORD=\$POSTGRES_PASSWORD \
                                    -t customhaven/blog_db:${env.BUILD_TAG} .
                                """
                            // dockerImageDB = docker.build("customhaven/blog_db:${env.BUILD_TAG}")
                            // Save the image tag to a variable for use in later stages
                            env.DOCKER_IMAGE_DB = "customhaven/blog_db:${env.BUILD_TAG}"
                        }
                    }
                }
            }
        }
        stage("Push Docker DB Image") {
            steps {
				script {
					docker.withRegistry("", "dockerhub") {
                        // using the env
                        sh "docker push ${env.DOCKER_IMAGE_DB}"
						// dockerImageDB.push()
						// dockerImageDB.push("${env.BUILD_TAG}")
					}
				}
			}
        }
        stage("Build Docker MVC Image") {
            steps {
                withCredentials([file(credentialsId: "blog_mvc_env", variable: "ENV_FILE_MVC")]) {
                    echo "Current directory before moving into blog_mvc"
                    sh "pwd"

                    dir("blog_mvc") {
                        echo "Current directory inside blog_mvc"
                        sh "pwd"
                        sh "ls"

                        script {
                            sh """
                            set -a
                            . \$ENV_FILE_MVC
                            set +a

                            # Build Docker image with environment variables
                            docker build \
                                --build-arg PORT=\$PORT \
                                --build-arg NODE_ENV=\$NODE_ENV \
                                --build-arg DB_USER=\$DB_USER \
                                --build-arg DB_HOST=\$DB_HOST \
                                --build-arg DB_NAME=\$DB_NAME \
                                --build-arg DB_PASSWORD=\$DB_PASSWORD \
                                --build-arg DB_PORT=\$DB_PORT \
                                --build-arg JWT_SECRET=\$JWT_SECRET \
                                -t customhaven/blog_mvc:${env.BUILD_TAG} .
                            """
                            env.DOCKER_IMAGE_MVC = "customhaven/blog_mvc:${env.BUILD_TAG}"
                            // dockerImageMVC = docker.image("customhaven/blog_mvc:${env.BUILD_TAG}")
                        }
                    }
                }
            }
        }
        stage("Push Docker MVC Image") {
			steps {
				script {
					docker.withRegistry("", "dockerhub") {
                        sh "docker push ${env.DOCKER_IMAGE_MVC}"
						// dockerImageMVC.push()
						// dockerImageMVC.push("${env.BUILD_TAG}")
					}
				}
			}
		}
        stage("Terraform Init") {
            steps {
                sh "pwd"
                sh """
                pwd
                cd ~/
                pwd
                ls -a
                """
                dir("terraform") {
                    sh "pwd"
                    sh "terraform init"
                }
            }
        }
        stage("Terraform Validate") {
            steps {
                dir("terraform") {
                    sh "terraform validate"
                }
            }
        }
        stage("Terraform Plan") {
            steps {
                echo "Looking if plan wille execute"
                dir("terraform") {
                    withCredentials([file(credentialsId: 'AWS_PEM_ID', variable: "AWS_KEY_PAIR")]) {
                        sh 'terraform plan -var="aws_key_pair=$(cat $AWS_KEY_PAIR)"'
                    }
                }
            }
        }
        stage("Terraform Apply") {
            steps {
                echo "About to see if apply works"
                dir("terraform") {
                    sh "terraform apply"
                }
            }
        }
    }
    post {
		always {
			echo "I always run"
            echo "Final Cleanups"
            dir("blog_mvc") {
                sh "rm -rf node_modules"
                sh "ls > ls.txt"
                sh "cat ls.txt"

                script {
                    def testTxtExists = sh(script: "grep 'test.txt' ls.txt", returnStatus: true) == 0
                    if (testTxtExists) {
                        sh "cat test.txt"
                        sh "rm test.txt"
                    }


                    def coverageFileExist = sh(script: "grep 'coverage.txt' ls.txt", returnStatus: true) == 0
                    if (coverageFileExist) {
                        sh "cat coverage.txt"
                        sh "rm coverage.txt"
                    }

                    def coverageExist = sh(script: "grep 'coverage' ls.txt", returnStatus: true) == 0
                    if (coverageExist) {
                        sh "rm -rf coverage"
                    }
                }
                sh "ls"
                sh "rm ls.txt"
                sh "ls"
            }
		}
		success {
			echo "I run when successful"
		}
		failure {
            script {
                withCredentials([usernamePassword(credentialsId: "e47030c6-b9aa-4279-8df1-5ebe235f9865", usernameVariable: "EMAIL_USER", passwordVariable: "EMAIL_PASS")]) {
                    emailext (
                        to: "havendepot@gmail.com,${EMAIL_USER}",
                        // cc: "${EMAIL_USER}", // should work might need to update emailext
                        // bcc: "${EMAIL_USER}", // should work might need to update emailext
                        subject: "Jenkins Pipeline Failed: ${env.JOB_NAME} ${env.BUILD_NUMBER}",
                        body: "The Jenkins pipeline has failed. Please check the build logs for details: ${env.BUILD_URL}",
                        from: "Jenkins Pipeline <${EMAIL_USER}>",
                        mimeType: "text/plain"
                    )
                }
            }
            echo "I run when failed"
            // Example of sending a Slack notification
            // slackSend channel: '#builds', message: "Pipeline failed: ${env.JOB_NAME} ${env.BUILD_NUMBER}. Check details: ${env.BUILD_URL}"
		}
	}
}

